package com.reactnativehyperkycsdk;

import android.app.Activity;
import android.content.Intent;
import android.util.Log;

import androidx.annotation.NonNull;

import com.facebook.react.ReactActivity;
import com.facebook.react.bridge.ActivityEventListener;
import com.facebook.react.bridge.Callback;
import com.facebook.react.bridge.ReactApplicationContext;
import com.facebook.react.bridge.ReactContextBaseJavaModule;
import com.facebook.react.bridge.ReactMethod;
import com.facebook.react.bridge.ReadableMap;
import com.facebook.react.bridge.ReadableMapKeySetIterator;
import com.facebook.react.bridge.ReadableType;
import com.facebook.react.bridge.UiThreadUtil;
import com.facebook.react.bridge.WritableMap;
import com.facebook.react.bridge.WritableNativeMap;
import com.facebook.react.modules.core.DeviceEventManagerModule;
import com.google.gson.Gson;

import org.json.JSONObject;

import java.util.HashMap;
import java.util.Map;

import co.hyperverge.hyperkyc.HyperKyc;
import co.hyperverge.hyperkyc.data.models.HyperKycConfig;
import co.hyperverge.hyperkyc.data.models.result.HyperKycResult;
import kotlin.Unit;
import kotlin.jvm.functions.Function1;

public class HyperkycSdkModule extends ReactContextBaseJavaModule {
    public static final String NAME = "Hyperkyc";
    private final ReactApplicationContext reactContext;
    private final int HYPERKYC_REQUEST_CODE = 56455;
    private boolean isEventListenerAdded = false;

    public HyperkycSdkModule(ReactApplicationContext reactContext) {
        super(reactContext);
        this.reactContext = reactContext;
    }

    @Override
    @NonNull
    public String getName() {
        return NAME;
    }

    @ReactMethod
    public void createUniqueId(Callback callback) {
        callback.invoke(HyperKyc.createUniqueId());
    }

    @ReactMethod
    public void prefetch(String appId, String workflowId) {
        if (getReactApplicationContext() != null) {
            HyperKyc.prefetch(getReactApplicationContext(), appId, workflowId);
        }
    }

    @ReactMethod
    public void addEventListener() {
        isEventListenerAdded = true;
    }

    @ReactMethod
    public void removeAllEventListeners() {
        HyperKyc.removeAllEventListeners();
        isEventListenerAdded = false;
    }

    @ReactMethod
    public void launch(ReadableMap kycConfig, Callback resultCallback) {
        ReactActivity currentActivity = (ReactActivity) getCurrentActivity();
        assert kycConfig != null;
        HyperKycConfig config = getHyperKycConfigFromMap(kycConfig);
        HyperKyc.Contract contract = new HyperKyc.Contract();

        reactContext.addActivityEventListener(new ActivityEventListener() {
            @Override
            public void onActivityResult(Activity activity, int requestCode, int resultCode, Intent data) {
                if (requestCode == HYPERKYC_REQUEST_CODE) {
                    HyperKycResult hyperKycResult = contract.parseResult(resultCode, data);
                    parseKYCResult(hyperKycResult, resultCallback);
                } else {
                    resultCallback.invoke(getDummyResultMap());
                }
                reactContext.removeActivityEventListener(this);
            }

            @Override
            public void onNewIntent(Intent intent) {
            }
        });

        if (isEventListenerAdded) {
            Function1<JSONObject, Unit> listener = jsonObject -> {
                try {
                    WritableMap eventMap = HyperkycSdkUtils.convertJsonToMap(jsonObject);
                    UiThreadUtil.runOnUiThread(() -> sendEvent("onHyperKycEvent", eventMap));
                } catch (Exception e) {
                    Log.e(NAME, e.getLocalizedMessage());
                }
                return Unit.INSTANCE;
            };
            HyperKyc.addEventListener(listener);
        }

        if (currentActivity != null) {
            Intent newIntent = contract.createIntent(currentActivity, config);
            currentActivity.startActivityIfNeeded(newIntent, HYPERKYC_REQUEST_CODE);
        } else {
            resultCallback.invoke(getDummyResultMap());
        }
    }

    private void sendEvent(String eventName, WritableMap eventProperties) {
        if (reactContext.hasActiveCatalystInstance()) {
            reactContext
                    .getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter.class)
                    .emit(eventName, eventProperties);
        }
    }

    private void parseKYCResult(HyperKycResult hyperKycResult, Callback callback) {
        try {
            Gson gson = new Gson();
            String resultJSON = gson.toJson(hyperKycResult);
            JSONObject result = new JSONObject(resultJSON);
            WritableMap resultMap = HyperkycSdkUtils.convertJsonToMap(result);
            callback.invoke(resultMap);
        } catch (Exception e) {
            if (e.getLocalizedMessage() != null) {
                Log.e(NAME, e.getLocalizedMessage());
            } else {
                Log.e(NAME, "error parsing hyperKycResult");
            }
            callback.invoke(getDummyResultMap());
        }
    }

    private Map<String, Object> processReadableMap(ReadableMap rm) {
        Map<String, Object> map = new HashMap<>();
        ReadableMapKeySetIterator iterator = rm.keySetIterator();
        while (iterator.hasNextKey()) {
            String key = iterator.nextKey();
            ReadableType type = rm.getType(key);

            // Handle different types of values
            switch (type) {
                case Number:
                    double numberValue = rm.getDouble(key);
                    // Check if the value is an integer by comparing its fractional part
                    if (numberValue == Math.rint(numberValue)) { // rint rounds to the nearest integer
                        map.put(key, (int) numberValue); // It's an int, cast and put as Integer
                    } else {
                        map.put(key, numberValue); // It's a double
                    }
                    break;
                case Boolean:
                    map.put(key, rm.getBoolean(key));
                    break;
                default:
                    map.put(key, rm.getString(key));
            }
        }
        return map;
    }

    private HyperKycConfig getHyperKycConfigFromMap(ReadableMap kycConfig) {
        String appId = kycConfig.hasKey("appId") ? kycConfig.getString("appId") : null;
        String appKey = kycConfig.hasKey("appKey") ? kycConfig.getString("appKey") : null;
        String accessToken = kycConfig.hasKey("accessToken") ? kycConfig.getString("accessToken") : null;
        String workflowId = kycConfig.hasKey("workflowId") ? kycConfig.getString("workflowId") : null;
        String transactionId = kycConfig.hasKey("transactionId") ? kycConfig.getString("transactionId") : null;
        ReadableMap inputs = kycConfig.hasKey("inputs") ? kycConfig.getMap("inputs") : null;
        String defaultLangCode = kycConfig.hasKey("defaultLangCode") ? kycConfig.getString("defaultLangCode") : null;
        Boolean useLocation = kycConfig.hasKey("useLocation") ? kycConfig.getBoolean("useLocation") : null;
        String uniqueId = kycConfig.hasKey("uniqueId") ? kycConfig.getString("uniqueId") : null;
        Map<String, String> metadata = new HashMap<>();
        metadata.put("sdk-version", "0.46.1");
        metadata.put("sdk-type", "React Native");
        if (accessToken == null) {
            assert appId != null;
            assert appKey != null;
            assert workflowId != null;
            assert transactionId != null;
            HyperKycConfig hyperKycConfig = new HyperKycConfig(appId, appKey, workflowId, transactionId);
            if (inputs != null) {
                hyperKycConfig.setInputs(processReadableMap(inputs));
            }
            if (defaultLangCode != null) {
                hyperKycConfig.setDefaultLangCode(defaultLangCode);
            }
            if (useLocation != null) {
                hyperKycConfig.setUseLocation(useLocation);
            }
            if (uniqueId != null) {
                hyperKycConfig.setUniqueId(uniqueId);
            }
            hyperKycConfig.addMetadata(metadata);

            return hyperKycConfig;
        } else {
            assert workflowId != null;
            assert transactionId != null;
            HyperKycConfig hyperKycConfig = new HyperKycConfig(accessToken, workflowId, transactionId);
            if (inputs != null) {
                hyperKycConfig.setInputs(processReadableMap(inputs));
            }
            if (defaultLangCode != null) {
                hyperKycConfig.setDefaultLangCode(defaultLangCode);
            }
            if (useLocation != null) {
                hyperKycConfig.setUseLocation(useLocation);
            }
            if (uniqueId != null) {
                hyperKycConfig.setUniqueId(uniqueId);
            }
            hyperKycConfig.addMetadata(metadata);

            return hyperKycConfig;
        }
    }

    private WritableMap getDummyResultMap() {
        WritableMap dummyResult = new WritableNativeMap();
        dummyResult.putString("status", "");
        dummyResult.putString("transactionId", "");
        dummyResult.putInt("errorCode", 0);
        dummyResult.putString("errorMessage", "");
        dummyResult.putString("latestModule", "");
        dummyResult.putMap("details", new WritableNativeMap());
        return dummyResult;
    }

    @ReactMethod
    private void addListener(String eventName) {
        // Required for RN built-in EventEmitter support.
        // Can be empty if we don't need per-event management.
    }

    @ReactMethod
    private void removeListeners(int count) {
        // Required for RN built-in EventEmitter support.
        // Can be empty if we don't need per-event management.
    }
}